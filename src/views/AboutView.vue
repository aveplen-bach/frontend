<template>
  <div class="container pt-3 pb-3">
    <div class="card">
      <div class="card-body almost-whole-screen-card">
        <h3 class="text-center">О приложении</h3>
        <p class="card-text">
          Приложение для демонстрации работы системы разделения доступа с
          применением механизма двухфакторной аутентификации по биометрическим
          данным и паролю. Создано с применением микросервисной архитектуры,
          языков Go, Python в качестве серверных ЯП, TypeScript в качестве
          исходного ЯП для клиента. Клиентская часть создана с применением
          фреймворков Vue.js и Bootstrap.css. Серверная часть реализована на
          базе gRPC, в качестве транспорта сообщений между сервисами, и
          фреймворка Gin.
        </p>

        <hr />

        <h4 class="text-center">Разработанный алгоритм</h4>

        <p>
          Для решения основной задачи данной работы был разработан алгоритм
          двухфакторной аутентификации пользователей при удаленном доступе по
          паролю и биометрическим данным – фотографии лица пользователя, который
          основан на идеях и принципах работы протоколов
          <a href="https://ru.wikipedia.org/wiki/S/Key">S/Key</a> и
          <a href="https://ru.wikipedia.org/wiki/RADIUS"> RADIUS </a>. Протокол
          на два этапа - аутентификацию в системе и доступ к защищенному
          ресурсу. Этап аутентификации состоит из четырех этапов:
        </p>

        <ol>
          <li>
            Клиент направляет серверу запрос аутентификации, состоящий из
            уникального идентификатора пользователя
            <strong>ID</strong> (логином) и номером сообщения в рамках процедуры
            аутентификации <strong> stage = 1 </strong>.
          </li>

          <li>
            Сервер увеличивает значение счетчика
            <strong> stage </strong>
            на <strong> 1 </strong>, генерирует случайное уникальное число
            <strong> R </strong>, и направляет его клиенту в качестве согласия
            на проведение аутентификации.
          </li>

          <li>
            Клиент использует полученное число <strong> R </strong> в качестве
            случайной добавки для выведения из своего пароля
            <strong> P </strong> сессионного ключа шифрования
            <strong> SK = pbkdf(R, P) </strong>, шифрует изображение лица FP,
            увеличивает значение счетчика <strong> stage </strong> на
            <strong> 1 </strong> и направляет серверу сообщение из шифротекста
            <strong> E(SK, FP) </strong> и счетчика <strong> stage </strong>.
          </li>

          <li>
            Сервер, используя сгенерированное число <strong> R </strong>, и
            пароль пользователя <strong> P </strong>, полученный из базы данных
            по идентификатору <strong> ID </strong>, выводит свой сессионный
            ключ <strong> SK = pbkdf(R, P) </strong>, расшифровывает полученное
            от клиента изображение <strong> FP = D(SK, E(SK,FP)) </strong>,
            получает из изображения вектор <strong> DFFV </strong>, сравнивает с
            вектором <strong> SFFV </strong>, полученным из базы данных, и
            принимает решение в зависимости от расстояния двух векторов
            <strong> Euclidean(DFFV, SFFV) </strong>. Если решение об
            аутентификации пользователя положительно, то сервер генерирует
            случайное число <strong> S </strong>, формирует из идентификатора
            пользователя <strong> ID </strong>, подписанного по алгоритму
            электронной подписи вместе с идентификатором использованного
            алгоритма <strong> DSC </strong>, электронной подписи
            <strong> DS </strong> и числа <strong> S </strong> токен доступа
            <strong> T </strong>, описанный выше, шифрует первую секцию
            полученного токена на сессионном ключе <strong> SK </strong> и
            направляет пользователю <strong> E(SK,T[0]).T[1:] </strong>.
          </li>
        </ol>

        <p>
          Для сохранения уровня защищенности, достигнутого посредством
          использования разработанного алгоритма также был разработан токен
          авторизации последующих сообщений, который используется для доступа к
          защищенным ресурсам. Этап доступа к защищенному ресурсу:
        </p>

        <ol>
          <li>
            Пользователь расшифровывает первую секцию токена
            <strong> T </strong>, при помощи сессионного ключа
            <strong> SK </strong>, извлекает из него счетчик
            <strong> S </strong>, увеличивает его значение, согласно
            определенному протоколу, зашифровывает новый токен, состоящий из
            <strong> S’ </strong>, <strong> DSC </strong>,
            <strong> DS </strong> на том же сессионном ключе
            <strong> SK </strong> и направляет серверу вместе с запросом на
            получение защищенного ресурса.
          </li>

          <li>
            Сервер, получив от пользователя запрос с токеном
            <strong> T </strong>, расшифровывает его, извлекает счетчик
            <strong> S </strong> и сверяет с его ожидаемым значением
            <strong> S’’ </strong>. Если ожидаемое значение совпало с
            действительным, сервер извлекает идентификатор алгоритма электронной
            подписи <strong> DSC </strong> идентификатора пользователя
            <strong> ID </strong>, электронную подпись <strong> DS </strong> и
            проверяет ее. Если проверка успешна, то сервер на основе
            идентификатора решает, может ли пользователь получить доступ к
            запрашиваемому ресурсу. Если может, то значение счетчика
            <strong> S </strong> увеличивается, согласно протоколу, и новый
            токен <strong> T </strong> направляется пользователю вместе с
            данными.
          </li>
        </ol>

        <h4 class="text-center">Токен аутентификации сообщений</h4>

        <p>
          Для аутентификации сообщений на этапе доступа к защищенному ресурсу
          протокол использует токен, предназначенный идентифицировать
          пользователя компьютерной системы, и одновременно с этим предоставлять
          и серверу, и клиенту доказательство того, что они оба обладают одним и
          тем же базовым секретом. Для соблюдения этих требований был разработан
          токен, состоящий из четырех секций, каждая из которых представлена
          блоком данных в формате
          <a href="https://ru.wikipedia.org/wiki/JSON"> JSON </a>. Описание
          секций приведено ниже.
        </p>

        <ol>
          <li>
            <strong>Sync</strong> – секция, отвечающая за аутентификацию каждого
            сообщения. Она состоит, как минимум, из одного поля
            <strong> syn </strong> – случайного числа, которое генерируется
            сервером на стадии выдачи токена сервером. Чтобы аутентифицировать
            свои сообщения, субъект должен изменить значение счетчика
            <strong> syn </strong>
            относительно предыдущего значения согласно установленному контракту.
            Основная использования поля syn заключается в том, что блок, в
            котором оно находится зашифрован одним из алгоритмов симметричного
            шифрования, что не позволяет нарушителю, не имеющему сессионного
            ключа изменять значение счетчика, и, соответственно,
            аутентифицировать сообщения. Также эта часть может содержать
            некоторую конфиденциальную информацию, которую клиент и сервер хотят
            защитить шифрованием, но эта информация не может идентифицировать
            пользователя в системе, потому что это секция не подписывается при
            помощи электронной подписи.
          </li>

          <li>
            <strong> Header </strong> – секция, содержащая информацию,
            необходимую для уточнения контракта общения клиента с сервером. К
            такой информации относится выбор алгоритмов шифрования, хэширования,
            электронной подписи, тип токена и др.
          </li>

          <li>
            <strong> Payload </strong> – секция, состоящая из информации,
            необходимой для определения полномочий и прав доступа к ресурсам
            пользователя, предоставившего токен. Эта часть токена не
            подвергается симметричному шифрованию, поэтому не может содержать
            конфиденциальной информации, которая может дать доступ к защищенным
            данным и ресурсам.
          </li>

          <li>
            <strong> Signature </strong> – электронная подпись секций
            <strong> Header </strong> и <strong> Payload </strong>. Необходима
            для того, чтобы клиент в ходе диалога с сервером не мог поменять
            своей идентификационной информации, прав доступа или условий
            контракта.
          </li>
        </ol>

        <p>
          Таким образом токен подходит под выдвинутые требования – он
          идентифицирует пользователя в компьютерной системе путем
          предоставления идентифицирующих данных в открытом виде, подмена
          идентифицирующих данных невозможна благодаря электронной подписи,
          знание базового секрета обеими сторонами гарантируется необходимостью
          изменять зашифрованную часть токена.
        </p>

        <p>
          Предложенный токен предполагается использовать в качестве значения
          заголовка “Authorization”
          <a href="https://ru.wikipedia.org/wiki/HTTP"> HTTP </a>
          запроса в виде четырех строк в кодировке
          <a href="https://ru.wikipedia.org/wiki/Base64"> base64 </a>,
          соединенных между собой точкой. Схематично такой сценарий
          использования приведен на рисунке.
        </p>

        <h4 class="text-center">
          Оценка защищенности разработанного протокола
        </h4>

        <p>
          Протокол предназначается для использования в незащищенных сетях,
          поэтому он может быть подвержен атакам типа «человек по середине»
        </p>

        <p>
          При атаке типа «человек по середине» на этапе аутентификации
          нарушитель может получить идентификатор пользователя, однако защитить
          от раскрытия идентификатор пользователя не представляется возможным,
          так как он косвенно используется для формирования сессионного ключа
          шифрования. Возможным решением проблемы раскрытия идентификатора может
          быть использование хэш-значения идентификатора, однако это открывает
          возможность словарной атаки на идентификатор. Чтобы уменьшить
          количество анализируемой нарушителем информации, сервер может отвечать
          продолжением диалога для любого, даже не существующего в система,
          идентификатора. Также нарушитель может перехватить токен
          аутентификации, но протокол предусматривает расшифрование, изменение
          счетчика синхронизации, и обратное шифрование на сессионном ключе при
          каждом доступе к защищенному ресурсу, не зная сессионного ключа,
          нарушитель не сможет совершить ни одного запроса.
        </p>

        <p>
          На этапе доступа к ресурсам нарушитель, обладающий токеном доступа, не
          сможет подменить свой идентификатор для доступа к ресурсам, которые
          ему не доступны, потому что идентификатор защищен алгоритмом
          электронной подписи, как часть секции
          <strong> payload </strong> токена.
        </p>

        <h4 class="text-center">Оценка расширяемости протокола</h4>

        <p>
          Анализируя разработанный протокол, можно обратить внимание на то, что
          в дизайне заложено несколько точек расширения, а именно:
        </p>

        <ol>
          <li>
            Протокол не фиксирует алгоритмы шифрования, хэширования и
            электронной подписи, поэтому он может быть расширен на любой новый
            алгоритм или сразу несколько алгоритмов с установлением соглашения
            между клиентом и сервером при первом обращении.
          </li>

          <li>
            Алгоритм не фиксирует генераторы случайных чисел, а также содержимое
            секции токена <strong> sync </strong>, что позволяет расширить ее
            полем, содержащим случайную прибавку к полю <strong> syn </strong>,
            которую ожидает увидеть сторона-собеседник. Таким образом
            добавлением одного поля можно запретить досрочную генерацию токенов
            для последующих запросов, что может повысить безопасность системы.
          </li>

          <li>
            Алгоритм не фиксирует никакое содержимое токена аутентификации,
            кроме счетчика синхронизации, идентификаторов используемых
            алгоритмов и электронной подписи. Поэтому, токен может быть расширен
            любой информацией, которая может упростить процесс проверки прав
            доступа клиента к защищенному ресурсу, не умаляя безопасности.
            Например, можно расширить токен идентификатором группы, в которой
            состоит пользователь, или списком доступных ресурсов.
          </li>
        </ol>
        <p>
          Таким образом был разработан протокол, который является некоторой
          модификацией протокола непрямой аутентификации RADIUS, основным
          отличием которой от классического определения RADIUS является то, что
          серверы-агенты могут удостовериться в целостности данных,
          идентифицирующих клиента, и запустить процесс формирования ответа
          заранее – до ответа сервера аутентификации. Это достигается за счет
          того, что аутентифицирующая часть токена не связана с
          идентифицирующей.
        </p>

        <hr />

        <p>
          Выполнил: Студент 4-го курса бакалавриата НИУ МЭИ Пленкин Алексей,
          группа А-05-18.
        </p>
      </div>
    </div>
  </div>
</template>

<script lang="ts" setup></script>

<style>
.almost-whole-screen-card {
  min-height: 85vh;
}
</style>
